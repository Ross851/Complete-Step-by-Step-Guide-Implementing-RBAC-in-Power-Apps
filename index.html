<!DOCTYPE html>
<html lang="en-GB">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Complete Step-by-Step Guide: Implementing RBAC in Power Apps (Enhanced Edition)</title>

  <style>
    /* =========================
       PART 1: BASE STYLES
       ========================= */
    /* Basic Layout and Resets */
    body {
      font-family: Arial, sans-serif;
      background: #f5f5f5;
      padding: 0;
      margin: 0;
      color: #222; /* darker text for better contrast */
      line-height: 1.6;
    }
    .page-container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }

    /* Section Styling */
    .section {
      background: #fff;
      padding: 20px;
      border-radius: 5px;
      margin-bottom: 25px;
      box-shadow: 0 0 5px rgba(0,0,0,0.1);
    }
    h1 {
      color: #2c5898;
      text-align: center;
      margin-top: 0;
      margin-bottom: 5px;
    }
    .last-updated {
      text-align: center;
      font-size: 0.9rem;
      color: #666;
      margin-bottom: 30px;
    }
    h2 {
      color: #2c5898;
      margin-top: 0;
      border-bottom: 1px solid #eee;
      padding-bottom: 10px;
      scroll-margin-top: 20px;
    }
    h3 {
      color: #4472c4;
      margin-top: 20px;
      scroll-margin-top: 20px;
    }

    /* Lists & Tables */
    ul, ol {
      padding-left: 25px;
      margin-bottom: 20px;
    }
    li {
      margin-bottom: 8px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
    }
    th, td {
      border: 1px solid #ddd;
      padding: 8px;
      text-align: left;
    }
    th {
      background-color: #f2f2f2;
    }
    tr:nth-child(even) {
      background-color: #f9f9f9;
    }

    /* Alert Boxes */
    .note {
      background-color: #e6f3ff;
      padding: 15px;
      border-left: 4px solid #4472c4;
      margin: 15px 0;
    }
    .warning {
      background-color: #fff8e6;
      padding: 15px;
      border-left: 4px solid #f0ad4e;
      margin: 15px 0;
    }
    .danger {
      background-color: #ffe6e6;
      padding: 15px;
      border-left: 4px solid #d9534f;
      margin: 15px 0;
    }

    /* Implementation Type Badges */
    .implementation-type {
      display: inline-block;
      padding: 3px 8px;
      border-radius: 3px;
      font-size: 0.8em;
      margin-right: 10px;
    }
    .bronze {
      background-color: #cd7f32;
      color: white;
    }
    .silver {
      background-color: #c0c0c0;
      color: white;
    }
    .gold {
      background-color: #ffd700;
      color: #333;
    }

    /* Key Points & Summaries */
    .key-points {
      background-color: #eaf7ea;
      padding: 15px;
      border-left: 4px solid #5cb85c;
      margin: 15px 0;
    }
    .summary-box {
      background-color: #f1fce6;
      border-left: 4px solid #8ebf4d;
      padding: 15px;
      margin: 15px 0;
    }
    .summary-box h4 {
      margin-top: 0;
      margin-bottom: 10px;
      font-size: 1.1em;
      color: #496c2e;
    }

    /* Code Blocks + "Copy Code" Buttons */
    pre {
      margin: 0 0 15px 0;
      position: relative; /* for "Copy" button positioning */
    }
    code {
      display: block;
      background: #272822;
      color: #f8f8f2;
      padding: 15px;
      border-radius: 3px;
      overflow-x: auto;
      line-height: 1.4;
      font-family: Consolas, Monaco, 'Andale Mono', monospace;
    }
    .inline-code {
      background: #f0f0f0;
      padding: 2px 4px;
      border-radius: 3px;
      font-family: Consolas, Monaco, 'Andale Mono', monospace;
      color: #d63384;
    }

    .copy-button {
      position: absolute;
      top: 8px;
      right: 8px;
      background: #4472c4;
      color: #fff;
      border: none;
      padding: 6px 10px;
      cursor: pointer;
      font-size: 0.8rem;
      border-radius: 4px;
    }
    .copy-button:hover {
      background: #2c5898;
    }

    /* Table of Contents */
    .toc {
      background-color: #f8f8f8; 
      padding: 15px; 
      border-radius: 5px; 
      margin: 20px 0;
    }
    .toc h3 {
      margin-top: 0;
      color: #333;
    }
    .toc ul {
      padding-left: 20px;
    }
    .toc li {
      margin-bottom: 5px;
    }
    .toc a {
      color: #2c5898;
      text-decoration: none;
    }
    .toc a:hover {
      text-decoration: underline;
    }

    /* Dark Mode Example */
    @media (prefers-color-scheme: dark) {
      body {
        background: #121212;
        color: #e0e0e0;
      }
      .section {
        background: #1e1e1e;
        box-shadow: 0 0 5px rgba(255,255,255,0.1);
      }
      code {
        background: #2d2d2d;
      }
      .note, .warning, .danger, .toc, .summary-box, .key-points {
        background: #2a2a2a;
        border-left-color: #888;
      }
      table, th, td {
        background: #2a2a2a;
        color: #ccc;
        border-color: #444;
      }
      th {
        background-color: #3a3a3a;
      }
    }

    /* ==============================================
       PART 2: VISUAL FLAIR — TIER COLUMNS STYLES
       ============================================== */
    :root {
      --bronze-color: #cd7f32;
      --silver-color: #c0c0c0;
      --gold-color: #ffd700;
      --text-dark: #333;
      --text-light: #fff;
      --bg-color: #fafafa;
    }
    
    @media (prefers-color-scheme: dark) {
      :root {
        --bronze-color: #8B4513;
        --silver-color: #808080;
        --gold-color: #B8860B;
        --text-dark: #f0f0f0;
        --text-light: #fff;
        --bg-color: #121212;
      }
    }

    /* Container for the RBAC tiers overview */
    .visual-flair-container {
      display: flex;
      justify-content: center;
      align-items: stretch;
      margin: 20px auto;
      max-width: 1200px;
      gap: 15px;
    }

    .tier-heading {
      text-align: center;
      margin: 20px 0 0 0;
      color: var(--text-dark);
    }

    /* Each tier's column */
    .tier {
      flex: 1;
      margin: 10px;
      padding: 20px;
      border-radius: 8px;
      min-width: 250px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      display: flex;
      flex-direction: column;
    }

    .tier.bronze {
      background-color: var(--bronze-color);
      color: var(--text-light);
    }
    .tier.silver {
      background-color: var(--silver-color);
      color: var(--text-dark);
    }
    .tier.gold {
      background-color: var(--gold-color);
      color: var(--text-dark);
    }

    .tier h2 {
      margin-top: 0;
      font-size: 1.5rem;
      text-align: center;
      border-bottom: 1px solid rgba(255,255,255,0.3);
      padding-bottom: 10px;
    }

    .tier-subtitle {
      text-align: center;
      font-style: italic;
      margin-bottom: 20px;
    }

    .icon {
      display: flex;
      justify-content: center;
      margin: 10px 0 20px 0;
      height: 60px;
      align-items: center;
    }

    .step {
      background-color: rgba(255,255,255,0.15);
      padding: 12px;
      border-radius: 6px;
      margin-bottom: 15px;
      font-size: 0.95rem;
    }
    .step-title {
      font-weight: bold;
      margin-bottom: 5px;
      display: block;
    }

    .arrow {
      text-align: center;
      margin: 5px 0;
      font-size: 1.2rem;
      color: rgba(255,255,255,0.7);
    }

    @media (max-width: 768px) {
      .visual-flair-container {
        flex-direction: column;
        align-items: stretch;
      }
      .step {
        font-size: 0.9rem;
      }
    }
  </style>
</head>
<body>

<div class="page-container">
  <h1>Complete Step-by-Step Guide: Implementing RBAC in Power Apps (Enhanced Edition)</h1>
  <p class="last-updated">Last Updated: May 2025</p>

  <div class="toc">
    <h3>Table of Contents</h3>
    <ul>
      <li><a href="#introduction">Introduction</a></li>
      <li><a href="#key-concepts">Key Concepts &amp; Terminology</a></li>
      <li><a href="#planning">Step 1: Planning Your RBAC Strategy</a></li>
      <li><a href="#azure-ad-groups">Step 2: Set Up Azure AD Security Groups</a></li>
      <li><a href="#store-group-ids">Step 3: Store Security Group IDs</a></li>
      <li><a href="#bronze-method">Step 4: Bronze Method - Basic Implementation</a></li>
      <li><a href="#silver-method">Step 5: Silver Method - Custom Connector</a></li>
      <li><a href="#gold-method">Step 6: Gold Method - Advanced Implementation</a></li>
      <li><a href="#dataverse-security">Step 7: Aligning with Dataverse Security</a></li>
      <li><a href="#role-management">Step 8: Dynamic Role Management</a></li>
      <li><a href="#access-requests">Step 9: Self-Service Access Requests</a></li>
      <li><a href="#rbac-analytics">Step 10: RBAC Analytics &amp; Monitoring</a></li>
      <li><a href="#testing">Step 11: Testing &amp; Validation</a></li>
      <li><a href="#troubleshooting">Step 12: Troubleshooting Guide</a></li>
      <li><a href="#best-practices">Best Practices &amp; Scale Considerations</a></li>
      <li><a href="#conclusion">Conclusion &amp; Next Steps</a></li>
      <li><a href="#visual-tiers">Visual RBAC Tiers Overview</a></li>
      <li><a href="#authors">About the Authors</a></li>
    </ul>
  </div>

  <!-- INTRODUCTION -->
  <div class="section" id="introduction">
    <h2>Introduction</h2>
    <p>
      This comprehensive guide provides a step-by-step roadmap for implementing <strong>Role-Based Access Control (RBAC)</strong> in Power Apps. It has been updated to improve readability and help developers easily copy and paste code in smaller, more digestible chunks, while also addressing <em>recent Microsoft API limits</em>, potential usage of <strong>isInRole()</strong>, advanced security concerns, and more.
    </p>
    <p>
      You will learn how to effectively manage UI visibility and data access based on user roles, with an emphasis on <strong>Azure AD Security Groups</strong> and the <strong>Microsoft Graph API</strong>. We also highlight the importance of <em>back-end data enforcement</em> and various techniques for optimising performance, including caching, handling throttling, and dealing with large group memberships.
    </p>

    <h3>Business Value of RBAC</h3>
    <ul>
      <li><strong>Enhanced Security:</strong> Enforce least privilege principles.</li>
      <li><strong>Improved Compliance:</strong> Meet industry regulatory needs.</li>
      <li><strong>Reduced Support Costs:</strong> Minimise user errors related to unauthorised access.</li>
      <li><strong>Better User Experience:</strong> Cleaner UI showing relevant features only.</li>
      <li><strong>Scalable Management:</strong> Centrally manage permissions via Azure AD groups.</li>
    </ul>

    <h3>Implementation Approaches</h3>
    <p>
      This guide presents three methods of increasing sophistication:
    </p>
    <ul>
      <li>
        <span class="implementation-type bronze">Bronze</span>  
        Basic implementation using built-in connectors – ideal for small teams and straightforward apps.
      </li>
      <li>
        <span class="implementation-type silver">Silver</span>  
        Enhanced implementation with a custom connector – suitable for departmental apps with multiple roles.
      </li>
      <li>
        <span class="implementation-type gold">Gold</span>  
        Advanced implementation with nested groups, caching strategies, and logging – designed for enterprise-wide apps.
      </li>
    </ul>

    <div class="note">
      <strong>API Limits Note:</strong> 
      Keep in mind <a href="https://learn.microsoft.com/en-us/power-platform/admin/api-request-limits-allocations" target="_blank">Microsoft's recent API limits</a> for the Power Platform. Plan your calls (especially in large deployments) to avoid throttling.
    </div>
  </div>

  <!-- KEY CONCEPTS -->
  <div class="section" id="key-concepts">
    <h2>Key Concepts &amp; Terminology</h2>
    <ul>
      <li><strong>RBAC (Role-Based Access Control):</strong> Restricts system access based on user roles.</li>
      <li><strong>Azure AD Security Groups:</strong> Logical groupings of users for access control.</li>
      <li><strong>Microsoft 365 Groups vs. Security Groups:</strong> Security groups are tailored to permission management.</li>
      <li><strong>Custom Connectors:</strong> Extensions allowing Power Apps to communicate with APIs (e.g., Graph).</li>
      <li><strong>Microsoft Graph API:</strong> Gateway to Microsoft 365 data/services, including Azure AD group membership.</li>
      <li><strong>Power Apps Variables:</strong> App-scoped or global variables to store settings and user state.</li>
      <li><strong>Collections:</strong> In-memory tables for data manipulations within an app.</li>
      <li><strong>Environment Variables:</strong> Centrally stored configuration values in the Power Platform environment.</li>
      <li><strong>Dataverse Security:</strong> Backend database security that controls data operations but not UI elements.</li>
    </ul>

    <div class="warning">
      <strong>Important:</strong> Power Apps Canvas apps do <em>not</em> automatically inherit Dataverse security for the UI. Use <strong>frontend RBAC</strong> to manage visibility, but also enforce data security at the backend for true protection.
    </div>
  </div>

  <!-- STEP 1 -->
  <div class="section" id="planning">
    <h2>Step 1: Planning Your RBAC Strategy</h2>
    
    <h3>Role Inheritance Design</h3>
    <p>Before coding, outline your role hierarchy:</p>
    <ul>
      <li><strong>Admin:</strong> Full access, including security management.</li>
      <li><strong>Editor:</strong> Create/modify content, no system settings access.</li>
      <li><strong>Reader:</strong> View-only.</li>
    </ul>

    <h3>Aligning Canvas App UI Security with Dataverse</h3>
    <p>
      If your app uses Dataverse, align your Canvas app roles with existing Dataverse security roles:
    </p>
    <table>
      <tr>
        <th>Azure AD Security Group</th>
        <th>Canvas App Role</th>
        <th>Dataverse Security Role</th>
      </tr>
      <tr>
        <td>App-Admin-Group</td>
        <td>Admin</td>
        <td>System Administrator</td>
      </tr>
      <tr>
        <td>App-Editor-Group</td>
        <td>Editor</td>
        <td>Basic User with Write</td>
      </tr>
      <tr>
        <td>App-Reader-Group</td>
        <td>Reader</td>
        <td>Basic User (read-only)</td>
      </tr>
    </table>

    <div class="danger">
      <strong>Key Security Note:</strong> Dataverse security controls data operations but does <em>not</em> affect UI elements. Always combine UI-based RBAC with correct backend security to protect sensitive operations and data.
    </div>

    <div class="summary-box">
      <h4>At a Glance – Planning</h4>
      <ul>
        <li>Define your roles &amp; hierarchies first (Admin, Editor, Reader, etc.).</li>
        <li>Decide how these roles map to Dataverse or other backend security models.</li>
        <li>Consider future roles (Approver, Auditor) and potential expansions.</li>
      </ul>
    </div>
  </div>

  <!-- STEP 2 -->
  <div class="section" id="azure-ad-groups">
    <h2>Step 2: Set Up Azure AD Security Groups</h2>
    <ol>
      <li>In the <strong>Azure Portal</strong>, go to <strong>Azure Active Directory</strong> → <strong>Groups</strong>.</li>
      <li>Create a <strong>Security Group</strong> for each role (YourApp-Admins, YourApp-Editors, YourApp-Readers, etc.).</li>
      <li>Add users to these groups as appropriate.</li>
      <li>Record each group’s <strong>Object ID</strong> from the group’s Overview page.</li>
    </ol>

    <div class="note">
      <strong>Naming Convention Best Practice:</strong> Include your app name in the group name (e.g., <em>InventoryApp-Admins</em>) to simplify identification when multiple apps exist.
    </div>

    <div class="warning">
      <h3>UPN vs. Email Alignment</h3>
      <p>
        In many organisations, <strong>Azure AD security groups</strong> identify users by their 
        <em>User Principal Name (UPN)</em>, while Power Apps commonly references <em>User().Email</em>.
        If these two fields don't match (e.g., <code>user@domain.com</code> vs. <code>alias@domain.com</code>), 
        group membership checks might fail or give incorrect results.
      </p>
      <ul>
        <li><strong>Check Real Identifiers:</strong> Use <code>Office365Users.MyProfileV2().userPrincipalName</code> or 
          <em>Graph</em> queries to confirm the user’s UPN if Azure AD group membership is keyed to the UPN.</li>
        <li><strong>Normalise Where Possible:</strong> If your environment standardises on email == UPN, 
          you can pass <code>User().Email</code> to your membership checks. Otherwise, 
          store <code>gblUserUPN</code> or <code>gblUserEmail</code> and ensure you're consistent 
          when calling Graph/Office365Users.</li>
        <li><strong>Fallback / Logging:</strong> If needed, store both the user’s UPN and email in your RBAC logs, 
          ensuring consistent correlation across systems.</li>
      </ul>
      <p>
        <strong>Recommendation:</strong> Double-check how your Azure AD tenant manages user identities. 
        If your users have different UPNs vs. emails, align them in the app logic or normalise to a single 
        source of truth (e.g., userPrincipalName).
      </p>
    </div>

    <div class="summary-box">
      <h4>At a Glance – Azure AD Groups</h4>
      <ul>
        <li>Use <em>Security Groups</em> rather than Microsoft 365 Groups for permission-specific tasks.</li>
        <li>Consistent naming (e.g., <code>YourApp-Role</code>) helps keep things organised.</li>
        <li>Note each group’s <strong>Object ID</strong> for referencing in your app’s configuration.</li>
      </ul>
    </div>
  </div>

  <!-- STEP 3 -->
  <div class="section" id="store-group-ids">
    <h2>Step 3: Store Security Group IDs</h2>
    
    <p>
      You need to store group IDs so your app can reference them. Possible storage options include:
    </p>

    <h3>Option A: SharePoint List (Simpler)</h3>
    <ol>
      <li>Create a <strong>SharePoint</strong> list called <strong>AppConfig</strong> with <strong>Title</strong> (Text) and <strong>Value</strong> (Text).</li>
      <li>Add rows such as:
        <ul>
          <li><code>SecurityGroupAdmin</code> → <em>[Admin Group Object ID]</em></li>
          <li><code>SecurityGroupEditor</code> → <em>[Editor Group Object ID]</em></li>
          <li><code>SecurityGroupReader</code> → <em>[Reader Group Object ID]</em></li>
          <li><code>AppVersion</code> → <em>1.0</em></li>
          <li><code>LastRoleUpdate</code> → <em>[Current date]</em></li>
          <li><code>RoleCacheDurationHours</code> → <em>4</em></li>
        </ul>
      </li>
    </ol>

    <h3>Option B: Environment Variables (More Secure)</h3>
    <ol>
      <li>In the Power Platform Admin Center, open your environment.</li>
      <li>Create environment variables named <em>SecurityGroupAdmin</em>, <em>SecurityGroupEditor</em>, etc.</li>
      <li>Assign appropriate group IDs and other config values.</li>
    </ol>

    <h3>Option C: Dataverse Table (Enterprise-Ready)</h3>
    <ol>
      <li>Create a custom <strong>Dataverse</strong> table named <em>Application Configuration</em>.</li>
      <li>Add columns for <em>Name</em> (Text) and <em>Value</em> (Text).</li>
      <li>Populate it with your role group IDs, app version, etc.</li>
      <li>Restrict edit permissions to admins only.</li>
    </ol>

    <div class="note">
      <strong>Alternative:</strong> Storing values in Azure Key Vault or Azure Storage is possible (often for compliance), but typically requires custom connectors or flows for secure retrieval.
    </div>

    <div class="summary-box">
      <h4>At a Glance – Group ID Storage</h4>
      <ul>
        <li>Select storage (SharePoint, Environment Variables, or Dataverse) based on your security &amp; scale needs.</li>
        <li>Maintain consistent naming (e.g., "SecurityGroupAdmin").</li>
        <li>Make updates easy so you can pivot if group structures change.</li>
      </ul>
    </div>
  </div>

  <!-- STEP 4 - BRONZE METHOD -->
  <div class="section" id="bronze-method">
    <h2>Step 4: <span class="implementation-type bronze">Bronze Method</span> – Basic Implementation</h2>
    <p>
      The <strong>Bronze Method</strong> relies on the built-in <em>Office365Users</em> connector to check group memberships. This is ideal for smaller apps—under ~100 users—and simpler security requirements.
    </p>

    <div class="note">
      <strong>About isInRole() (Preview):</strong>  
      Some Power Apps environments support a function called <code>isInRole()</code> (currently in preview). It can simplify membership checks:
    </div>

    <pre><code>
// Simple isInRole() usage example
If(
   isInRole("SecurityGroupEditor"), 
   Navigate(EditorScreen), 
   Navigate(ViewScreen)
);
</code></pre>

    <p><em>Limitations:</em> <code>isInRole()</code> may not support nested groups yet, and not all tenants have it enabled. Check official documentation or release notes before relying on it in production.</p>

    <h3>Step 4.1: Add the Office365Users Connector</h3>
    <ol>
      <li>In your Canvas app, open <strong>Data</strong> → <strong>Add data</strong>.</li>
      <li>Select <strong>Office365Users</strong>.</li>
      <li>Connect to the config storage from Step 3 (SharePoint, environment variables, etc.).</li>
    </ol>

    <h3>Step 4.2: Basic OnStart Logic, in Chunks</h3>
    <p>Below is typical code for your App’s <strong>OnStart</strong> property, broken into smaller parts.</p>

    <pre><code>
// PART A: INITIAL SETUP & CACHING

// 1. Set app version & initial flags
Set(gblAppVersion, "1.0");
Set(gblIsInitialized, false);

// 2. Attempt to load previously saved user security
Set(gblUserCache, LoadData(App, "UserSecurityCache_" & Text(User().Email)));

// 3. Determine how many hours to cache roles
Set(gblRoleCacheDuration,
    If(
        !IsBlank(LookUp(AppConfig, Title = "RoleCacheDurationHours").Value),
        Value(LookUp(AppConfig, Title = "RoleCacheDurationHours").Value),
        4
    )
);
</code></pre>

    <pre><code>
// PART B: CHECK CACHE VALIDITY

If(
    // If cache is missing or expired, we refresh
    IsEmpty(gblUserCache) ||
    DateDiff(Now(), gblUserCache.Timestamp) > gblRoleCacheDuration ||
    gblUserCache.Email <> User().Email,

    // Cache invalid
    Set(gblSecurityNeedsRefresh, true);
    Set(gblUserRoles, If(IsEmpty(gblUserCache), [], gblUserCache.Roles));
    Set(gblIsAdmin, If(IsEmpty(gblUserCache), false,
                  LookUp(gblUserCache.RoleFlags, Role="Admin").HasAccess));
    Set(gblIsEditor, If(IsEmpty(gblUserCache), false,
                  LookUp(gblUserCache.RoleFlags, Role="Editor").HasAccess));
    Set(gblIsReader, If(IsEmpty(gblUserCache), false,
                  LookUp(gblUserCache.RoleFlags, Role="Reader").HasAccess));

    // Cache valid
    Set(gblSecurityNeedsRefresh, false);
    Set(gblUserRoles, gblUserCache.Roles);
    Set(gblIsAdmin,  LookUp(gblUserCache.RoleFlags, Role="Admin").HasAccess);
    Set(gblIsEditor, LookUp(gblUserCache.RoleFlags, Role="Editor").HasAccess);
    Set(gblIsReader, LookUp(gblUserCache.RoleFlags, Role="Reader").HasAccess)
);
</code></pre>

    <pre><code>
// PART C: VISIBILITY FLAGS & TIMER TRIGGER

// Pre-compute flags for common UI scenarios
Set(gblShowAdminFeatures, gblIsAdmin);
Set(gblShowEditorFeatures, gblIsEditor || gblIsAdmin);
Set(gblShowReaderFeatures, gblIsReader || gblIsEditor || gblIsAdmin);

// Mark UI as ready to reference these flags
Set(gblUICachingReady, true);

// If security needs refresh, start a Timer to load after UI
If(gblSecurityNeedsRefresh, UpdateContext({_startSecurityLoadTimer: true}));

// Mark app initialized
Set(gblIsInitialized, true);
</code></pre>

    <div class="note">
      <strong>Deferred Loading Tip:</strong>  
      Use a Timer (e.g. <code>tmrSecurityLoad</code>) so the main screen appears faster. If the load fails, handle errors with more specific messages, e.g.:
      <ul>
        <li>“Unable to load groups due to network issues. Using cached roles.”</li>
        <li>“Office365Users connector returned an invalid response.”</li>
      </ul>
      This helps troubleshoot exact problems.
    </div>

    <h3>Step 4.3: LoadUserSecurity Function</h3>
    <pre><code>
// LoadUserSecurity: triggered by the Timer or a Refresh button

Set(LoadUserSecurity, () => {

    // 1. Prevent parallel loads
    If(gblSecurityLoading, 
       Notify("Security loading is already in progress.");
       Exit()
    );
    Set(gblSecurityLoading, true);

    // 2. Fetch group IDs from config
    Set(varSecurityGroupAdmin,  LookUp(AppConfig, Title="SecurityGroupAdmin").Value);
    Set(varSecurityGroupEditor, LookUp(AppConfig, Title="SecurityGroupEditor").Value);
    Set(varSecurityGroupReader, LookUp(AppConfig, Title="SecurityGroupReader").Value);

    // 3. Use Office365Users (watch for errors)
    Set(locUserGroups,
        IfError(
            Office365Users.UserGetMemberGroups(User().Email).value,
            Notify("Error loading security groups. Using cached permissions if available.", NotificationType.Error);
            Set(gblInitError, true);
            []
        )
    );

    // 4. Determine role access
    Set(gblIsAdmin,  varSecurityGroupAdmin in locUserGroups);
    Set(gblIsEditor, varSecurityGroupEditor in locUserGroups);
    Set(gblIsReader, varSecurityGroupReader in locUserGroups);

    ClearCollect(gblUserRoles,
        {roleName:"SecurityGroupAdmin",  hasAccess:gblIsAdmin},
        {roleName:"SecurityGroupEditor", hasAccess:gblIsEditor},
        {roleName:"SecurityGroupReader", hasAccess:gblIsReader}
    );

    // 5. Visibility flags
    Set(gblShowAdminFeatures,  gblIsAdmin);
    Set(gblShowEditorFeatures, gblIsEditor || gblIsAdmin);
    Set(gblShowReaderFeatures, gblIsReader || gblIsEditor || gblIsAdmin);

    // 6. Cache the updated security
    SaveData(
        App,
        "UserSecurityCache_" & Text(User().Email),
        {
            Email: User().Email,
            Roles: gblUserRoles,
            RoleFlags: Table(
               {Role:"Admin",  HasAccess:gblIsAdmin},
               {Role:"Editor", HasAccess:gblIsEditor},
               {Role:"Reader", HasAccess:gblIsReader}
            ),
            Timestamp: Now()
        }
    );

    // 7. Logging or analytics as needed

    // 8. Final
    Set(gblSecurityNeedsRefresh, false);
    Set(gblIsSecurityLoaded, true);
    Set(gblSecurityLoading, false);
});
</code></pre>

    <div class="danger">
      <strong>Defence-in-Depth Reminder:</strong>  
      UI-based RBAC can be bypassed by determined users. Always combine with backend-level enforcement (Dataverse or SharePoint item-level security, row-level security in SQL, etc.).
    </div>

    <h3>Step 4.4: Controlling UI Visibility</h3>
    <pre><code>
// Example: Buttons or forms that require certain roles

AdminButton.Visible: gblShowAdminFeatures
EditButton.Visible: gblShowEditorFeatures
ViewButton.Visible: gblShowReaderFeatures

// Fields that only Admin/Editors can edit
SomeFormField.DisplayMode: 
   If(gblShowEditorFeatures, DisplayMode.Edit, DisplayMode.View);
</code></pre>

    <div class="summary-box">
      <h4>At a Glance – Bronze Method</h4>
      <ul>
        <li>Uses the built-in <em>Office365Users</em> connector for membership checks.</li>
        <li>Suitable for smaller user bases or simpler security demands.</li>
        <li>Use caching to reduce repeated calls and handle potential network/connector issues.</li>
        <li><code>isInRole()</code> can simplify checks if available, but may not handle nested groups.</li>
      </ul>
    </div>
  </div>

  <!-- STEP 5 - SILVER METHOD -->
  <div class="section" id="silver-method">
    <h2>Step 5: <span class="implementation-type silver">Silver</span> Method – Custom Connector</h2>
    <p>
      The <strong>Silver Method</strong> uses a <em>custom connector</em> to Microsoft Graph, allowing better control over the authentication flow, schema definitions, and performance. This is recommended for medium-scale apps or those needing multiple roles.
    </p>

    <h3>Step 5.1: Register an Azure AD Application</h3>
    <ol>
      <li>Go to <strong>Azure Active Directory</strong> → <strong>App registrations</strong> in the Azure Portal.</li>
      <li>Register a new app (e.g., <em>PowerApps-RBAC-Connector</em>).</li>
      <li>Under <strong>API Permissions</strong>, add Microsoft Graph → Delegated permissions → <strong>Group.Read.All</strong>, then grant admin consent.</li>
      <li>Under <strong>Certificates &amp; secrets</strong>, create a <em>client secret</em> and note its value.</li>
    </ol>

    <div class="warning">
      <strong>Security Note:</strong><br>
      Keep the client secret secure. Use OAuth 2.0 so calls respect user-based delegation and comply with your tenant’s policies. You can also implement refresh token strategies to reduce re-authentication overhead.
      <br /><br />
      <em>Client Secret Management:</em> For production apps, consider storing the secret in <strong>Azure Key Vault</strong> (or a similar secret store). Exposing it directly in environment variables or solution files can pose security risks if not handled carefully.
    </div>

    <h3>Step 5.2: Create the Custom Connector</h3>
    <ol>
      <li>In <strong>Power Apps</strong>, select <strong>Data</strong> → <strong>Custom connectors</strong>.</li>
      <li>Create a new connector with <strong>OAuth 2.0 (Azure AD)</strong>, using the app’s client ID/secret and <code>Group.Read.All</code> as permissions.</li>
      <li>Define the request/response schemas (for example, <em>GetUserMemberships</em> → calls <code>/users/{upn}/memberOf</code>).</li>
      <li>Save and test.</li>
    </ol>

    <div class="note">
      <strong>Example Schema Definition:</strong>  
      In the connector’s definition, specify <code>OperationId</code>: <em>GetUserMemberships</em>, <em>GET</em> on <code>/users/{userPrincipalName}/memberOf</code>, and parse the JSON response into a user-friendly format.
    </div>

    <h3>Step 5.3: Updated LoadUserSecurity</h3>
    <p>
      Replace <em>Office365Users</em> calls with your new <strong>AzureGroupConnector</strong>. This supports more complex checks and can handle advanced scenarios:
    </p>

    <pre><code>
// SILVER LoadUserSecurity (using Custom Connector)

Set(LoadUserSecurity, () => {
    If(gblSecurityLoading, Exit());
    Set(gblSecurityLoading, true);

    // Step A: Pull config
    ClearCollect(colRoleConfigs, Filter(AppConfig, StartsWith(Title, "SecurityGroup")));

    // Step B: Call custom connector
    Set(locUserGroupsResponse,
        IfError(
            AzureGroupConnector.GetUserMemberships(User().Email).value,
            Notify("Error with AzureGroupConnector. Using cached roles if available.", NotificationType.Error);
            Set(gblInitError, true);
            []
        )
    );

    // Step C: Convert response to ID list
    Set(locUserGroupIDs, ForAll(locUserGroupsResponse, id));

    // Step D: Determine role access
    Set(gblUserRoles,
        ForAll(
            colRoleConfigs,
            {
                roleName: Title,
                groupId: Value,
                hasAccess: Value in locUserGroupIDs
            }
        )
    );

    Set(gblIsAdmin,  !IsEmpty(Filter(gblUserRoles, roleName="SecurityGroupAdmin"  && hasAccess)));
    Set(gblIsEditor, !IsEmpty(Filter(gblUserRoles, roleName="SecurityGroupEditor" && hasAccess)));
    Set(gblIsReader, !IsEmpty(Filter(gblUserRoles, roleName="SecurityGroupReader" && hasAccess)));

    // Step E: Visibility flags
    Set(gblShowAdminFeatures, gblIsAdmin);
    Set(gblShowEditorFeatures, gblIsEditor || gblIsAdmin);
    Set(gblShowReaderFeatures, gblIsReader || gblIsEditor || gblIsAdmin);

    // Step F: Cache
    SaveData(
        App,
        "UserSecurityCache_" & Text(User().Email),
        {
            Email: User().Email,
            Roles: gblUserRoles,
            Timestamp: Now()
        }
    );

    // Step G: Final
    Set(gblSecurityNeedsRefresh, false);
    Set(gblIsSecurityLoaded, true);
    Set(gblSecurityLoading, false);
});
</code></pre>

    <div class="warning">
      <strong>Handling Large Memberships &amp; Throttling:</strong>
      <ul>
        <li><em>Pagination</em>: If a user is in hundreds of groups, the Graph API may return paginated results. Check for <code>@odata.nextLink</code> in responses and loop until all data is retrieved.</li>
        <li><em>429 Errors</em>: Use exponential backoff or retry logic to respect throttling policies.</li>
      </ul>
    </div>

    <div class="summary-box">
      <h4>At a Glance – Silver Method</h4>
      <ul>
        <li>Custom connector to Microsoft Graph for richer membership checks.</li>
        <li>Ideal for mid-scale scenarios where Bronze might be too limited.</li>
        <li>Enables fine-tuned requests and advanced parsing (JSON schemas).</li>
        <li>Plan for pagination and throttling in large environments.</li>
      </ul>
    </div>
  </div>

  <!-- STEP 6 - GOLD METHOD -->
  <div class="section" id="gold-method">
    <h2>Step 6: <span class="implementation-type gold">Gold</span> Method – Advanced Implementation</h2>
    <p>
      The <strong>Gold Method</strong> extends the Silver approach with <strong>nested/transitive group checks</strong>, robust caching, and in-depth auditing. This is tailored for large enterprises—e.g., 500+ users or 25+ roles.
    </p>

    <h3>Nested or Transitive Membership Checks</h3>
    <p>
      In Microsoft Graph, <code>/users/{userPrincipalName}/transitiveMemberOf</code> can reveal nested group memberships (i.e., groups inside groups). Remember to handle pagination and throttling similarly.
    </p>

    <h3>Example Code (Gold Method)</h3>
    <pre><code>
// GOLD: Handle nested groups, advanced caching & logging

Set(LoadUserSecurity, () => {

    If(gblSecurityLoading, Exit());
    Set(gblSecurityLoading, true);

    // Step 1: Retrieve configured group IDs
    ClearCollect(colRoleConfigs, Filter(AppConfig, StartsWith(Title,"SecurityGroup")));

    // Step 2: Use advanced Graph call for transitive memberships
    Set(locTransitiveResponse,
        IfError(
            AzureGroupConnector.AdvancedMembershipCheck(User().Email).value,
            Notify("Error loading nested group memberships. Using cached roles if available.", NotificationType.Error);
            Set(gblInitError, true);
            []
        )
    );

    // Step 3: Flatten to ID list (handle pagination via @odata.nextLink if needed)
    Set(locUserGroupIDs, ForAll(locTransitiveResponse, id));

    // Step 4: Determine role access
    Set(gblUserRoles, 
        ForAll(
            colRoleConfigs,
            {
                roleName: Title,
                groupId: Value,
                hasAccess: Value in locUserGroupIDs
            }
        )
    );

    Set(gblIsAdmin, !IsEmpty(Filter(gblUserRoles, roleName="SecurityGroupAdmin"  && hasAccess)));
    Set(gblIsEditor,!IsEmpty(Filter(gblUserRoles, roleName="SecurityGroupEditor" && hasAccess)));
    Set(gblIsReader,!IsEmpty(Filter(gblUserRoles, roleName="SecurityGroupReader" && hasAccess)));

    // Step 5: Visibility
    Set(gblShowAdminFeatures, gblIsAdmin);
    Set(gblShowEditorFeatures, gblIsEditor || gblIsAdmin);
    Set(gblShowReaderFeatures, gblIsReader || gblIsEditor || gblIsAdmin);

    // Step 6: Advanced caching + version check
    SaveData(
        App,
        "UserSecurityCache_" & Text(User().Email),
        {
          Email: User().Email,
          Roles: gblUserRoles,
          Timestamp: Now(),
          AppVersion: LookUp(AppConfig, Title="AppVersion").Value
        }
    );

    // Step 7: Detailed logging or auditing
    // e.g. Patch a "RBAC Audit Logs" table in Dataverse

    Set(gblSecurityNeedsRefresh, false);
    Set(gblIsSecurityLoaded, true);
    Set(gblSecurityLoading, false);
});
</code></pre>

    <div class="warning">
      <strong>Large-Scale Considerations:</strong>
      <ul>
        <li><em>Batch membership checks</em> in a queue if needed to avoid spikes.</li>
        <li>Implement <em>backoff logic</em> for 429 errors or repeated calls.</li>
        <li><em>Pagination</em> is essential if a single user belongs to thousands of nested groups.</li>
      </ul>
    </div>

    <div class="summary-box">
      <h4>At a Glance – Gold Method</h4>
      <ul>
        <li>Transitive group checks for nested group hierarchies.</li>
        <li>Advanced caching with version/triggers for refresh.</li>
        <li>Recommended for enterprise apps with large user bases (500+ users).</li>
        <li>Detailed logging/auditing at scale, plus robust error handling.</li>
      </ul>
    </div>
  </div>

  <!-- STEP 7: ALIGNING WITH DATAVERSE -->
  <div class="section" id="dataverse-security">
    <h2>Step 7: Aligning with Dataverse Security</h2>
    <p>
      If your backend is Dataverse, ensure your Canvas app roles match your Dataverse security roles. For instance, the group <strong>App-Admin-Group</strong> might map to <em>System Administrator</em>.
    </p>

    <div class="note">
      <strong>Important:</strong> Even if a user can’t see a “Delete” button in the UI, they might still call the connector directly. Dataverse roles must restrict <em>Delete</em> for non-admins to ensure data-level security.
    </div>

    <h3>Querying Dataverse Roles (Optional)</h3>
    <ul>
      <li><strong>Custom Connector:</strong> Query <code>systemuserroles_association</code> for the user, then cross-check with AD roles if needed.</li>
      <li><strong>Power Automate Flow:</strong> A flow with admin privileges can list a user’s Dataverse roles and return them to the app.</li>
    </ul>

    <div class="summary-box">
      <h4>At a Glance – Dataverse Alignment</h4>
      <ul>
        <li>Match AD security groups to existing Dataverse roles for consistency.</li>
        <li>Never rely solely on UI to restrict data actions—Dataverse must enforce record-level security.</li>
        <li>Consider extra logging or auditing in Dataverse if needed (e.g., Audit Logs).</li>
      </ul>
    </div>
  </div>

  <!-- STEP 8: DYNAMIC ROLE MANAGEMENT -->
  <div class="section" id="role-management">
    <h2>Step 8: Dynamic Role Management</h2>
    <p>
      Let admins adjust group → role mappings within the app itself. Typically, this involves an “Admin Screen” to edit group IDs in <strong>AppConfig</strong>.
    </p>

    <h3>Screen Example</h3>
    <pre><code>
// RoleManagementGallery items
RoleManagementGallery.Items:
    Filter(AppConfig, StartsWith(Title, "SecurityGroup"))

// Example editing logic in the gallery's button
btnSaveEdit.OnSelect:
    UpdateRoleConfiguration(ThisItem.Title, txtNewGroupID.Text)
</code></pre>

    <h3>Role Update Function</h3>
    <pre><code>
// PARTIAL EXAMPLE: Updating Role Config

Set(UpdateRoleConfiguration, (roleTitle, newGroupID) => {
    If(
        gblIsAdmin,
        Patch(
            AppConfig,
            LookUp(AppConfig, Title=roleTitle),
            {Value: newGroupID}
        );
        Patch(
            AppConfig,
            LookUp(AppConfig, Title="LastRoleUpdate"),
            {Value: Text(Now(), DateTimeFormat.UTC)}
        );
        Notify("Role configuration updated.");

        // Optional: force refresh
        Set(gblSecurityNeedsRefresh, true);
        LoadUserSecurity();
    ,
        Notify("You do not have permission to update roles.")
    )
});
</code></pre>

    <div class="summary-box">
      <h4>At a Glance – Dynamic Role Management</h4>
      <ul>
        <li>Admins can update group IDs without republishing the app.</li>
        <li>Protect these screens behind <code>gblIsAdmin</code> checks and data-level security on AppConfig.</li>
        <li>Use <code>LastRoleUpdate</code> to trigger caches to refresh promptly.</li>
      </ul>
    </div>
  </div>

  <!-- STEP 9: SELF SERVICE ACCESS -->
  <div class="section" id="access-requests">
    <h2>Step 9: Self-Service Access Requests</h2>
    <p>
      If users need roles they don’t currently have, you can provide a request/approval workflow via Power Automate to minimise admin overhead.
    </p>

    <h3>Simple In-App Request Screen</h3>
    <pre><code>
// Example of a simple "Request Access" form
AccessRequestForm.DefaultMode = FormMode.New;

RequestRoleDropdown.Items =
Filter(
   Table(
       {Value: "Admin"}, 
       {Value: "Editor"}, 
       {Value: "Reader"}
   ),
   !(Value = "Admin" && gblIsAdmin) 
   && !(Value = "Editor" && (gblIsEditor || gblIsAdmin))
   && !(Value = "Reader" && (gblIsReader || gblIsEditor || gblIsAdmin))
);

SubmitRequestButton.OnSelect =
Collect(colAccessRequests,
    {
        UserEmail: User().Email,
        RequestedRole: RequestRoleDropdown.Selected.Value,
        Justification: txtJustification.Text,
        Status: "Pending",
        SubmittedDate: Now()
    }
);
PowerAutomate_Run("AccessRequestFlow", {
    userEmail: User().Email,
    requestedRole: RequestRoleDropdown.Selected.Value,
    justification: txtJustification.Text
});
Notify("Request submitted. You'll be notified upon approval.");
Navigate(HomeScreen);
</code></pre>

    <h3>Power Automate Flow</h3>
    <p>
      Create a flow triggered by Power Apps. It starts an approval, and if approved, adds the user to the relevant Azure AD group (requires proper Graph permissions or a privileged service principal).
    </p>

    <div class="summary-box">
      <h4>At a Glance – Self-Service Access</h4>
      <ul>
        <li>Reduces manual role administration.</li>
        <li>Flows handle approvals for security integrity.</li>
        <li>Combine with manager or admin approvals for critical roles.</li>
      </ul>
    </div>
  </div>

  <!-- STEP 10: RBAC ANALYTICS -->
  <div class="section" id="rbac-analytics">
    <h2>Step 10: RBAC Analytics &amp; Monitoring</h2>
    <p>
      Tracking events (role checks, access requests, updates) in a persistent store helps with audits and compliance.
    </p>

    <h3>Data Structures</h3>
    <ul>
      <li><strong>In-Memory Collection (Small Scale):</strong> <code>colRBACEvents</code> — ephemeral.</li>
      <li><strong>Dataverse Table (Enterprise):</strong> A “RBAC Audit Logs” table with columns like <em>UserEmail, EventType, Timestamp</em>.</li>
    </ul>

    <h3>Logging Example</h3>
    <pre><code>
// On role check or update
Patch(
   'RBAC Audit Logs',
   Defaults('RBAC Audit Logs'),
   {
       UserEmail: User().Email,
       EventType: "SecurityCheck",
       RoleName: If(gblIsAdmin, "Admin",
                    If(gblIsEditor, "Editor",
                    If(gblIsReader, "Reader", "None"))),
       Result: gblIsAdmin || gblIsEditor || gblIsReader,
       EventTimestamp: Now(),
       Details: "Checked roles on screen " & App.ActiveScreen.Name
   }
);
</code></pre>

    <div class="warning">
      <strong>Security Consideration:</strong> Keep these logs restricted to admins. They can reveal sensitive security data, like group IDs and roles.
    </div>

    <div class="summary-box">
      <h4>At a Glance – RBAC Analytics</h4>
      <ul>
        <li>Use Dataverse for persistent, queryable audit logs.</li>
        <li>Dashboard them for ongoing insights and compliance checks.</li>
        <li>Safeguard the logs themselves from unauthorised viewing.</li>
      </ul>
    </div>
  </div>

  <!-- STEP 11: TESTING -->
  <div class="section" id="testing">
    <h2>Step 11: Testing &amp; Validation</h2>
    <h3>Testing Checklist</h3>
    <ul>
      <li>Create test accounts for each role combination (Admin, Editor, Reader, None).</li>
      <li>Verify UI behaviour (hidden buttons, read-only forms, etc.).</li>
      <li>Test role changes in Azure AD to ensure the app detects them after caching expires or after a manual refresh.</li>
      <li>Assess performance with a large user count or many groups; watch for throttling or slow loads.</li>
      <li>Check logs to confirm correct event data and timestamps.</li>
    </ul>

    <h3>Performance Considerations</h3>
    <ul>
      <li>Defer security checks after UI loads (using timers) for better perceived performance.</li>
      <li>Monitor the volume of Graph calls to avoid hitting <em>Power Platform API limits</em> or Graph throttling.</li>
      <li>Implement caching strategies (like role updates only every few hours) if roles rarely change.</li>
    </ul>
  </div>

  <!-- STEP 12: TROUBLESHOOTING -->
  <div class="section" id="troubleshooting">
    <h2>Step 12: Troubleshooting Guide</h2>

    <h3>Common Issues &amp; Resolutions</h3>
    <table>
      <tr>
        <th>Issue</th>
        <th>Cause</th>
        <th>Solution</th>
      </tr>
      <tr>
        <td>Group checks always fail</td>
        <td>Incorrect/old group Object ID or UPN mismatch</td>
        <td>Verify IDs in AppConfig &amp; confirm user UPN vs. Email usage</td>
      </tr>
      <tr>
        <td>Slow app load</td>
        <td>Membership checks block UI</td>
        <td>Use deferred loading with a Timer, show partial UI first</td>
      </tr>
      <tr>
        <td>Graph returns 429</td>
        <td>Throttling</td>
        <td>Implement paging &amp; backoff logic; reduce call frequency</td>
      </tr>
      <tr>
        <td>Unauthorized elements visible</td>
        <td>Visibility flags not used properly</td>
        <td>Check <code>gblShowAdminFeatures</code>, etc., for each control</td>
      </tr>
      <tr>
        <td>Role changes not shown</td>
        <td>Stale cache</td>
        <td>Update <em>LastRoleUpdate</em>, or refresh manually</td>
      </tr>
    </table>

    <h3>Debugging Tips</h3>
    <ol>
      <li><strong>Monitor Tool</strong>: Inspect variable values &amp; connector calls in Power Apps Studio.</li>
      <li><strong>Temporary Debug Screen</strong>: Surface <code>gblIsAdmin</code>, <code>gblIsEditor</code>, <code>gblIsReader</code> to confirm correctness.</li>
      <li><strong>Test Different Accounts</strong>: Validate each role scenario thoroughly.</li>
      <li><strong>Graph/Office365Users Error Codes</strong>: Familiarise yourself with typical 400/403/429 errors to expedite resolution.</li>
    </ol>
  </div>

  <!-- BEST PRACTICES & SCALE -->
  <div class="section" id="best-practices">
    <h2>Best Practices &amp; Scale Considerations</h2>

    <h3>Small Scale (&lt;100 Users, &lt;10 Roles)</h3>
    <ul>
      <li>Bronze method (Office365Users) is usually enough.</li>
      <li>Store config in SharePoint or environment variables.</li>
      <li>Basic caching on <strong>OnStart</strong>.</li>
    </ul>

    <h3>Medium Scale (100–500 Users, 10–25 Roles)</h3>
    <ul>
      <li>Silver method with a custom connector.</li>
      <li>Potentially store config in Dataverse for security.</li>
      <li>Implement partial caching &amp; optional self-service requests.</li>
    </ul>

    <h3>Large Scale (500+ Users, 25+ Roles)</h3>
    <ul>
      <li>Gold method – advanced membership checks, caching, logging.</li>
      <li>Enterprise auditing (Dataverse, SIEM integration, etc.).</li>
      <li>Explicit throttling strategies &amp; performance monitoring.</li>
    </ul>

    <h3>Performance Optimisation</h3>
    <ul>
      <li><strong>Aggressive caching</strong> with version checks or time-based triggers.</li>
      <li><strong>Deferred loading</strong> so the UI is never blocked by membership checks.</li>
      <li>Use <strong>batch/partial checks</strong> if you suspect many Graph calls might cause throttling.</li>
      <li><strong>Pagination &amp; 429 handling</strong> for users in large numbers of groups.</li>
    </ul>
  </div>

  <!-- CONCLUSION -->
  <div class="section" id="conclusion">
    <h2>Conclusion &amp; Next Steps</h2>
    <p>
      By implementing RBAC using Bronze, Silver, or Gold methods, you enhance security, user experience, and scalability in your Power Apps.
    </p>

    <h3>Key Takeaways</h3>
    <ol>
      <li><strong>Front-End Security is Not Enough</strong><br />
        Pair UI-based RBAC with data-level security in Dataverse, SharePoint, or SQL.
      </li>
      <li><strong>Use Caching &amp; Handle Throttling</strong><br />
        Graph calls can be rate-limited; caching prevents excessive API usage.
      </li>
      <li><strong>Custom Connectors &amp; Graph API</strong><br />
        Offer more control and advanced capabilities but require additional configuration.
      </li>
      <li><strong>Administration &amp; Auditing</strong><br />
        Tools for managing roles dynamically and tracking security events are essential for compliance.
      </li>
    </ol>

    <h3>Next Steps</h3>
    <ol>
      <li>Enhance auditing with a “RBAC Audit Logs” table in Dataverse or integrate logs with SIEM (e.g., Microsoft Sentinel).</li>
      <li>Implement a “Request Access” flow for self-service, reducing admin tasks.</li>
      <li>Conduct load tests &amp; adopt advanced retry/paging logic for Microsoft Graph at enterprise scale.</li>
      <li>Harden your security posture with multi-layer defences (UI, backend, environment-level controls).</li>
    </ol>

    <div class="note">
      <strong>Continuous Improvement:</strong>  
      Security evolves over time. Revisit your RBAC approach regularly as Microsoft Graph, Power Apps capabilities, and compliance requirements change.
    </div>

    <div class="note">
      <strong>Downloadable Samples:</strong><br>
      We could also consider providing a sample Power Apps solution (e.g., a <em>.msapp</em> file or GitHub link) illustrating the Bronze method. This would helps new developers see a working example immediately.
    </div>

    <div class="note">
      <strong>Interactive Elements (If Applicable):</strong><br>
      In a larger learning platform, we could offer collapsible code sections or tooltips for acronyms.
    </div>
  </div><!-- end conclusion section -->


  <!-- VISUAL FLAIR SECTION -->
  <div class="section" id="visual-tiers">
    <h2>Visual RBAC Tiers Overview</h2>
    <p>
      For a quick comparison of the three RBAC approaches—Bronze, Silver, and Gold—here’s a visual summary showing the typical steps and their suitability.
    </p>

    <h3 class="tier-heading">Compare Bronze, Silver, and Gold Methods</h3>
    <div class="visual-flair-container">
      <!-- Bronze Column -->
      <div class="tier bronze">
        <h2>Bronze Method</h2>
        <div class="tier-subtitle">Basic Implementation</div>
        
        <div class="icon">
          <!-- Basic icon for Bronze (aria-hidden) -->
          <svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
            <circle cx="9" cy="7" r="4"></circle>
            <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
            <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
          </svg>
        </div>
        
        <div class="step">
          <span class="step-title">Office365Users Connector</span>
          Uses built-in connector to check group memberships
        </div>
        
        <div class="arrow">↓</div>
        
        <div class="step">
          <span class="step-title">Direct Group Membership</span>
          Checks if user is directly in security groups
        </div>
        
        <div class="arrow">↓</div>
        
        <div class="step">
          <span class="step-title">Basic Caching</span>
          Uses LoadData/SaveData to avoid repeated calls
        </div>
        
        <div class="arrow">↓</div>
        
        <div class="step">
          <span class="step-title">UI Controls</span>
          Controls visibility based on global variables
        </div>
        
        <div class="arrow">↓</div>
        
        <div class="step">
          <span class="step-title">Suitable For</span>
          Small teams (&lt;100 users) with simple role needs
        </div>
      </div>
      
      <!-- Silver Column -->
      <div class="tier silver">
        <h2>Silver Method</h2>
        <div class="tier-subtitle">Enhanced Implementation</div>
        
        <div class="icon">
          <!-- Basic icon for Silver (aria-hidden) -->
          <svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path>
          </svg>
        </div>
        
        <div class="step">
          <span class="step-title">Azure AD App Registration</span>
          Register app in Azure AD for Graph API access
        </div>
        
        <div class="arrow">↓</div>
        
        <div class="step">
          <span class="step-title">Graph API Permissions</span>
          Configure Group.Read.All permission
        </div>
        
        <div class="arrow">↓</div>
        
        <div class="step">
          <span class="step-title">Custom Connector</span>
          Build connector to Microsoft Graph API
        </div>
        
        <div class="arrow">↓</div>
        
        <div class="step">
          <span class="step-title">Direct Membership API</span>
          Call /users/{upn}/memberOf endpoint
        </div>
        
        <div class="arrow">↓</div>
        
        <div class="step">
          <span class="step-title">Enhanced Caching</span>
          Version-based caching with timestamps
        </div>
        
        <div class="arrow">↓</div>
        
        <div class="step">
          <span class="step-title">Suitable For</span>
          Medium deployments (100-500 users) with multiple roles
        </div>
      </div>
      
      <!-- Gold Column -->
      <div class="tier gold">
        <h2>Gold Method</h2>
        <div class="tier-subtitle">Advanced Implementation</div>
        
        <div class="icon">
          <!-- Basic icon for Gold (aria-hidden) -->
          <svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="12" cy="8" r="7"></circle>
            <polyline points="8.21 13.89 7 23 12 20 17 23 15.79 13.88"></polyline>
          </svg>
        </div>
        
        <div class="step">
          <span class="step-title">Advanced Graph API Integration</span>
          Complete API integration with error handling and throttling management
        </div>
        
        <div class="arrow">↓</div>
        
        <div class="step">
          <span class="step-title">Transitive Membership</span>
          Call /users/{upn}/transitiveMemberOf to check nested groups
        </div>
        
        <div class="arrow">↓</div>
        
        <div class="step">
          <span class="step-title">RBAC Auditing & Logging</span>
          Comprehensive logging in Dataverse tables with analytics
        </div>
        
        <div class="arrow">↓</div>
        
        <div class="step">
          <span class="step-title">Admin Management Interface</span>
          In-app configuration screen for admins to manage role settings
        </div>
        
        <div class="arrow">↓</div>
        
        <div class="step">
          <span class="step-title">Suitable For</span>
          Enterprise deployments (500+ users) with complex security requirements
        </div>
      </div>
    </div>
  </div><!-- end visual-tiers section -->

  <!-- ABOUT THE AUTHORS SECTION -->
  <div class="section" id="authors">
    <h2>About the Authors</h2>
</p>
<ul>
  <li>
    <strong><a href="https://www.linkedin.com/in/robert-rudokas-5385b0288" target="_blank">Robert Rudokas</a>:</strong>
    Robert is an <em>exceptionally creative problem-solver</em> whose journey into technology began with game modification, 
    where he discovered the power of bringing ideas to life through code. A Computer Science graduate from the University of Leicester, 
    Robert's contribution focuses on UI/UX transformations and integration excellence.
    <p>
    It was Robert who identified and solved the critical UPN/email alignment issue that would impact cross-tenant deployments—writing 
    custom code that seamlessly reconciled the differences between formats. He excels at integrating Power Automate with SQL for 
    sophisticated workflows, creating the user management components that make the RBAC framework both powerful and accessible.
    </p>
  </li>
  <li>
    <strong><a href="https://ross851.github.io/Bio/" target="_blank">Ross Hastie</a>:</strong>
    Ross brings military precision and technical expertise following a distinguished 22-year career in the British Army. 
    He conceived the <em>three-tiered RBAC model (Bronze, Silver, Gold)</em> that forms the foundation of this guide.
    <p>
    Building upon Robert's UPN/email solution, Ross developed the framework's architectural vision—creating reusable components, 
    custom connectors, and integration patterns. His approach links these elements into a cohesive system that balances security 
    with usability. With certifications in CompTIA and CMI Levels 5 and 6, Ross crafted the technical documentation and governance 
    guidelines that enable organisations to implement the framework confidently.
    </p>
  </li>
</ul>
<p>
  The partnership between Robert and Ross demonstrates how complementary skills lead to innovation. Robert's technical ingenuity 
  paired with Ross's component-based architecture created a solution greater than either could have developed independently.
</p>
<p>
  They welcome feedback and suggestions for enhancing this Power Apps security framework and are committed to continually refining it based on community input.
</p>
  </div>
  <!-- END ABOUT THE AUTHORS SECTION -->

</div><!-- end page-container -->

<script>
/* ==============================================
   PART 3: JAVASCRIPT FOR "COPY CODE" BUTTON
   ============================================== */

document.addEventListener('DOMContentLoaded', function() {
  // Select all <pre><code> blocks
  const codeBlocks = document.querySelectorAll('pre code');

  codeBlocks.forEach((block) => {
    // Create a "Copy" button
    const copyBtn = document.createElement('button');
    copyBtn.innerText = 'Copy';
    copyBtn.className = 'copy-button';

    // When button is clicked, copy the code text
    copyBtn.addEventListener('click', () => {
      // The actual text to copy:
      const codeText = block.innerText;
      // Copy to clipboard (requires HTTPS or localhost in most browsers)
      navigator.clipboard.writeText(codeText).then(() => {
        alert('Code copied to clipboard');
      }, (err) => {
        alert('Unable to copy code: ' + err);
      });
    });

    // Insert the button into the <pre> container
    // block.parentNode is the <pre> element
    block.parentNode.style.position = 'relative';
    block.parentNode.appendChild(copyBtn);
  });
});
</script>

</body>
</html>